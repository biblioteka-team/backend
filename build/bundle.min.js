(function (mongoose, express, morgan, cors, AdminJS, AdminJSExpress, mongoose$1, multer, dotenv) {
    'use strict';

    const authorSchema = new mongoose.Schema({
        name: {
            type: String,
            required: [true, "An author must have a name"],
            trim: true,
        },
        surname: {
            type: String,
            required: [true, "An author must have a surname"],
            trim: true,
        },
        name_ukr: {
            type: String,
            trim: true,
        },
        surname_ukr: {
            type: String,
            trim: true,
        }
    });

    const Author = mongoose.model("Author", authorSchema);

    const { Schema: Schema$2 } = mongoose;

    const bookSchema = new mongoose.Schema({
        title: {
            type: String,
            required: [true, "A book must have a title"],
            unique: true,
            trim: true,
            index: true
        },
        author_id: [{
            type: Schema$2.Types.ObjectId,
            ref: "Author",
            required: [true, "A book must have an author"],
            index: true
        }], 
        publisher_id: [{
            type: Schema$2.Types.ObjectId,
            ref: "Publisher",
            required: [true, "A book must have a publisher"],
            index: true
        }], 
        pagesQty: {
            type: Number,
            index: true
        },
        language_id: [{
            type: Schema$2.Types.ObjectId,
            ref: "Language",
            required: [true, "A book must have a language"],
            index: true
        }],
        summary: {
            type: String,
            required: [true, "A book must have a summary"],
            unique: true,
            trim: true,
            index: true
        },
        coverImageLink: [String],
        isbn: String,
        category_id: [{
            type: Schema$2.Types.ObjectId,
            ref: "Category",
            required: [true, "A book must have a category"],
            index: true
        }],
        publication_year: String,
        type: String,
        coverType: String,
        condition: String,
        title_ukr: {
            type: String,
            index: true
        },
        summary_ukr: String,
        coverImageLink_ukr: [String],
        created: { 
            type: Date,
            default: Date.now,
            index: true
          },
        price_id: {
            type: Schema$2.Types.ObjectId,
            ref: "Price",
            required: [true, "A book must have a price"],
            index: true
        },
        storage_id: {
            type: Schema$2.Types.ObjectId,
            ref: "Datastorage",
            index: true
        }
        
    }); 

    const Book = mongoose.model("Book", bookSchema);

    const { Schema: Schema$1 } = mongoose;

    const priceSchema = new mongoose.Schema({
        book_id: {
            type: Schema$1.Types.ObjectId,
            ref: "Book",
        },
        original_price: Number,
        discounted_price: Number

    });

    const Price = mongoose.model("Price", priceSchema);

    const publisherSchema = new mongoose.Schema({
        Publisher: {
            type: String,
            required: [true, "A book must have a publisher"],
            trim: true,
        }
    });

    const Publisher = mongoose.model("Publisher", publisherSchema);

    const languageSchema = new mongoose.Schema({
        language: String
    });

    const Language = mongoose.model("Language", languageSchema);

    const categorySchema = new mongoose.Schema({
        category: {
            type: String,
            required: [true, "A book must have a category"],
            trim: true,
        },
        category_ukr: {
            type: String,
            required: [true, "A book must have a category"],
            trim: true,
        }
    });

    const Category = mongoose.model("Category", categorySchema);

    const { Schema } = mongoose;

    const storageDataSchema = new mongoose.Schema({
        book_id: {
            type: Schema.Types.ObjectId,
            ref: "Book",
        },
        quantity: Number
    });

    const Storagedata = mongoose.model("Datastorage", storageDataSchema);

    AdminJS.registerAdapter({ Database: mongoose$1.Database, Resource: mongoose$1.Resource });

    const admin = new AdminJS({
        resources: [
            {
                resource: Author,
            },
            {
                resource: Book,
            },
            {
                resource: Price,
            },
            {
                resource: Publisher,
            },
            {
                resource: Language,
            },
            {
                resource: Category,
            },
            {
                resource: Storagedata,
            }
        ],
        rootPath: "/api/admin", 
    });

    const adminRouter = AdminJSExpress.buildRouter(admin);

    //Global error handler
    const catchAsync = (fn) => {
        return (req, res, next) => {
            fn(req, res, next).catch(next);
        };
    };

    const recommendBook =  async (category, bookId) => {
    try{
      const [recommendedBookByCategory] = await Promise.all([
            Category.aggregate([
                    {$match: {_id: category[0]._id }},
                    {$lookup: {
                        from: "books",
                        localField: "_id",
                        foreignField: "category_id",
                        as: "book",   
                        }
                    },
                    {
                        $unwind: {
                        path: "$book",
                        preserveNullAndEmptyArrays: true
                        }
                    },
                    {$lookup: {
                        from: "authors",
                        localField: "book.author_id",
                        foreignField: "_id",
                        as: "book.author"} 
                    },      
                    {$lookup: {
                        from: "categories",
                        localField: "book.category_id",
                        foreignField: "_id",
                        as: "book.category"} 
                    },
                    {$lookup: {
                        from: "prices",
                        localField: "book.price_id",
                        foreignField: "_id",
                        as: "book.price"} 
                    },
                    {
                        $group: {
                        "_id" : "$book._id",
                        "title": {"$first": "$book.title"},
                        "coverImageLink": {"$first": "$book.coverImageLink"},
                        "title_ukr": {"$first": "$book.title_ukr"},
                        "summary_ukr": {"$first": "$book.summary_ukr"},
                        "coverImageLink_ukr":  {"$first": "$book.coverImageLink_ukr"},
                        "author": {"$first": "$book.author"},
                        "price": {"$first": "$book.price"},
                        }
                    },
            ])
        ]);
        const recommendation = recommendedBookByCategory.filter(el => el._id != bookId);
        return  recommendation;               
        } catch (err) {
            console.error(err);
        }
    };

    const getNewAndSalesAndBestsellerBooks = catchAsync(async (req, res, next) => {
        try {
        const [newBooks, salesBooks, bestsellerBooks] = await Promise.all([
            //get new books by date
              Book.aggregate([
                { $sort: { created: -1 } },
                {$lookup: {
                  from: "authors",
                  localField: "author_id",
                  foreignField: "_id",
                  as: "author"} 
                },
                {$lookup: {
                  from: "publishers",
                  localField: "publisher_id",
                  foreignField: "_id",
                  as: "publisher"} 
                },
                {$lookup: {
                  from: "languages",
                  localField: "language_id",
                  foreignField: "_id",
                  as: "language"} 
                },
                {$lookup: {
                  from: "categories",
                  localField: "category_id",
                  foreignField: "_id",
                  as: "category"} 
                },
                {$lookup: {
                  from: "prices",
                  localField: "price_id",
                  foreignField: "_id",
                  as: "price"} 
                },
                { $unset: [ "author_id", "publisher_id", "language_id", "category_id", "price_id", "__v" ] },
                {
                  $group: {
                    "_id" : "$_id",
                    "title": {"$first": "$title"},
                    "summary": {"$first": "$summary"},
                    "coverImageLink": {"$first": "$coverImageLink"},
                    "isbn": {"$first": "$isbn"},
                    "publication_year": {"$first": "$publication_year"},
                    "type": {"$first": "$type"},
                    "condition": {"$first": "$condition"},
                    "title_ukr": {"$first": "$title_ukr"},
                    "summary_ukr": {"$first": "$summary_ukr"},
                    "coverImageLink_ukr":  {"$first": "$coverImageLink_ukr"},
                    "created": {"$first": "$created"},
                    "author": {"$first": "$author"},
                    "publisher": {"$first": "$publisher"},
                    "language": {"$first": "$language"},
                    "category": {"$first": "$category"},
                    "price": {"$first": "$price"}
                  }
                }
            ]),

            //get books with discounted price
            Price.aggregate([{$match: {
              discounted_price: { $gt: 0.0}
            }}, {
              $lookup: {
                from: "books",
                localField: "book_id",
                foreignField: "_id",
                as: "book"}
            }, 
            {
              $unwind: {
                path: "$book",
                preserveNullAndEmptyArrays: true
              }
            },
            {$lookup: {
              from: "authors",
              localField: "book.author_id",
              foreignField: "_id",
              as: "book.author"} 
            },
            {$lookup: {
              from: "publishers",
              localField: "book.publisher_id",
              foreignField: "_id",
              as: "book.publisher"} 
            },
            {$lookup: {
              from: "languages",
              localField: "book.language_id",
              foreignField: "_id",
              as: "book.language"} 
            },
            {$lookup: {
              from: "categories",
              localField: "book.category_id",
              foreignField: "_id",
              as: "book.category"} 
            },
            {$lookup: {
              from: "prices",
              localField: "book.price_id",
              foreignField: "_id",
              as: "book.price"} 
            },
            {
              $group: {
                "_id" : "$_id",
                "title": {"$first": "$book.title"},
                "summary": {"$first": "$book.summary"},
                "coverImageLink": {"$first": "$book.coverImageLink"},
                "isbn": {"$first": "$book.isbn"},
                "publication_year": {"$first": "$book.publication_year"},
                "type": {"$first": "$book.type"},
                "condition": {"$first": "$book.condition"},
                "title_ukr": {"$first": "$book.title_ukr"},
                "summary_ukr": {"$first": "$book.summary_ukr"},
                "coverImageLink_ukr":  {"$first": "$book.coverImageLink_ukr"},
                "created": {"$first": "$book.created"},
                "author": {"$first": "$book.author"},
                "publisher": {"$first": "$book.publisher"},
                "language": {"$first": "$book.language"},
                "category": {"$first": "$book.category"},
                "price": {"$first": "$book.price"}
              }}  
          ]),
           
            //get random bestsellers
            Book.aggregate([
            {$lookup: {
              from: "authors",
              localField: "author_id",
              foreignField: "_id",
              as: "author"} 
            },
            {$lookup: {
              from: "publishers",
              localField: "publisher_id",
              foreignField: "_id",
              as: "publisher"} 
            },
            {$lookup: {
              from: "languages",
              localField: "language_id",
              foreignField: "_id",
              as: "language"} 
            },
            {$lookup: {
              from: "categories",
              localField: "category_id",
              foreignField: "_id",
              as: "category"} 
            },
            {$lookup: {
              from: "prices",
              localField: "price_id",
              foreignField: "_id",
              as: "price"} 
            },
            { $unset: [ "author_id", "publisher_id", "language_id", "category_id", "price_id", "__v" ] },
            {
              $group: {
                "_id" : "$_id",
                "title": {"$first": "$title"},
                "summary": {"$first": "$summary"},
                "coverImageLink": {"$first": "$coverImageLink"},
                "isbn": {"$first": "$isbn"},
                "publication_year": {"$first": "$publication_year"},
                "type": {"$first": "$type"},
                "condition": {"$first": "$condition"},
                "title_ukr": {"$first": "$title_ukr"},
                "summary_ukr": {"$first": "$summary_ukr"},
                "coverImageLink_ukr":  {"$first": "$coverImageLink_ukr"},
                "created": {"$first": "$created"},
                "author": {"$first": "$author"},
                "publisher": {"$first": "$publisher"},
                "language": {"$first": "$language"},
                "category": {"$first": "$category"},
                "price": {"$first": "$price"}
              }
            }
            ])
        ]);
          res.json({
            newBooks: newBooks,
            salesBooks: salesBooks,
            bestsellerBooks: bestsellerBooks
        });
        } catch (err) {
            console.error(err);
            res.status(500).send('Internal Server Error');
        }

    });

    const getBookbyId = catchAsync(async (req, res, next) => {
        const bookById = await Book.findById(req.params.id).populate("price_id").populate("author_id")
        .populate("publisher_id").populate("language_id").populate("category_id"). populate("storage_id");

        const category = bookById.category_id;
        const bookId = req.params.id;
        
        const recommendation =  await recommendBook(category, bookId); 

        res.status(200).json({
          status: "success",
          bookById,
          recommendation    
        });
      });

    const searchBookByTitleByAuthor = catchAsync(async (req, res, next) => {
      let regex = new RegExp([req.query.q],'i');
      const searchedBookByTitle = await Book.aggregate([
        {$match: { $or: [{ title: regex }, { title_ukr: regex }]}},
        {$lookup: {
          from: "authors",
          localField: "author_id",
          foreignField: "_id",
          as: "author"} 
        },
        {$lookup: {
          from: "publishers",
          localField: "publisher_id",
          foreignField: "_id",
          as: "publisher"} 
        },
        {$lookup: {
          from: "languages",
          localField: "language_id",
          foreignField: "_id",
          as: "language"} 
        },
        {$lookup: {
          from: "categories",
          localField: "category_id",
          foreignField: "_id",
          as: "category"} 
        },
        {$lookup: {
          from: "prices",
          localField: "price_id",
          foreignField: "_id",
          as: "price"} 
        },
        { $unset: [ "author_id", "publisher_id", "language_id", "category_id", "price_id", "__v" ] },
    ]);


      const searchedBookByAuthor = await Author.aggregate([
      {$match: { $or: [{ name: regex }, { surname: regex }, { name_ukr: regex }, { surname_ukr: regex }]}},
      {$lookup: {
        from: "books",
        localField: "_id",
        foreignField: "author_id",
        as: "book",
        } 
      },
      {
        $unwind: {
          path: "$book",
          preserveNullAndEmptyArrays: true
        }
      },
      {$lookup: {
        from: "authors",
        localField: "book.author_id",
        foreignField: "_id",
        as: "book.author"} 
      },
      {$lookup: {
        from: "publishers",
        localField: "book.publisher_id",
        foreignField: "_id",
        as: "book.publisher"} 
      },
      {$lookup: {
        from: "languages",
        localField: "book.language_id",
        foreignField: "_id",
        as: "book.language"} 
      },
      {$lookup: {
        from: "categories",
        localField: "book.category_id",
        foreignField: "_id",
        as: "book.category"} 
      },
      {$lookup: {
        from: "prices",
        localField: "book.price_id",
        foreignField: "_id",
        as: "book.price"} 
      },
      {
        $group: {
          "_id" : "$_id",
          "title": {"$first": "$book.title"},
          "summary": {"$first": "$book.summary"},
          "coverImageLink": {"$first": "$book.coverImageLink"},
          "isbn": {"$first": "$book.isbn"},
          "publication_year": {"$first": "$book.publication_year"},
          "type": {"$first": "$book.type"},
          "condition": {"$first": "$book.condition"},
          "title_ukr": {"$first": "$book.title_ukr"},
          "summary_ukr": {"$first": "$book.summary_ukr"},
          "coverImageLink_ukr":  {"$first": "$book.coverImageLink_ukr"},
          "created": {"$first": "$book.created"},
          "author": {"$first": "$book.author"},
          "publisher": {"$first": "$book.publisher"},
          "language": {"$first": "$book.language"},
          "category": {"$first": "$book.category"},
          "price": {"$first": "$book.price"}
        }
      }
    ]);


       const searchResult = searchedBookByTitle != 0 ? searchedBookByTitle : searchedBookByAuthor ;

      res.status(200).json({
        status: "success",
        data: {
          searchResult
        },
      });

    });

      
    const booksData = {
        getNewAndSalesAndBestsellerBooks,
        getBookbyId,
        searchBookByTitleByAuthor, 
    };

    const bookRouter = express.Router();

    bookRouter
       .route("/")
       .get(booksData.getNewAndSalesAndBestsellerBooks);

    bookRouter
       .route("/search")
       .get(booksData.searchBookByTitleByAuthor);

    bookRouter
       .route("/:id")
       .get(booksData.getBookbyId);

    const app = express();

    //middlewares
    if (process.env.NODE_ENV === "development") {
        app.use(morgan("dev"));
    }
    const corsOptions = {
        source: "/api/(.*)",
        credentials: true,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
        allowedHeaders: [
              { "key": "Access-Control-Allow-Credentials", "value": "true" },
              { "key": "Access-Control-Allow-Origin", "value": "*" },
              { "key": "Access-Control-Allow-Methods", "value": "GET,OPTIONS,PATCH,DELETE,POST,PUT" },
              { "key": "Access-Control-Allow-Headers", "value": "X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version" }
            ],
            origin: ["http://localhost:5173", "https://frontend-sigma-three-18.vercel.app/api"],
            optionsSuccessStatus: 200,
    };

    app.use(cors(corsOptions));

    app.use(admin.options.rootPath, adminRouter);

    //test
    app.use(express.json());

    app.use("/api", bookRouter);

    dotenv.config({path: "./.env"});

    // import data from "./data/data-script.js";
    // const importStorageData =  data.importStorageData;

    // const uploadImageHandler = require("./utils/uploadImagesHandler.js")

    const DB = process.env.DATABASE.replace(
        "<PASSWORD>",
        process.env.PASSWORD
    );

    //connect to Mongo DB
    mongoose.connect(DB).then(() => {
        console.log("DB connected");
    });

    const port = 8080;

    app.listen(port, () => {
        console.log("app running");
    });

    // importStorageData();
    // const storage = multer.memoryStorage();
    // const upload = multer({ storage: storage });

    // app.post('/upload', upload.single('image'), uploadImageHandler);
    // Usage example:
    // const imagePath = './assets/ulysses.jpg'; // Replace with your image path
    // uploadImageToVercelBlob(imagePath).then(response => {
    //   console.log('Uploaded image response:', response);
    // }).catch(error => {
    //   console.error('Upload failed:', error);
    // });



    // updateData();

})(mongoose, express, morgan, cors, AdminJS, AdminJSExpress, mongoose$1, null, dotenv);
